<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="2D Animation Studio - Create frame-by-frame animations">
    <title>FrameBoy.v0</title>
    <!-- Gifshot library for GIF export (more reliable than gif.js) -->
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #2a2a2a;
            color: #e0e0e0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        /* Make it embeddable in Squarespace */
        body.embedded {
            background: transparent;
        }

        html {
            width: 100%;
            height: 100%;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            min-height: 400px;
            max-height: 100vh;
        }

        /* Make responsive for smaller screens */
        @media (max-width: 1024px) {
            .timeline-layers-section {
                width: 140px;
            }
            
            .frame {
                width: 60px;
                height: 60px;
            }
            
            .add-frame {
                width: 60px;
                height: 60px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                min-height: 400px;
            }
            
            .timeline-layers-section {
                width: 110px;
            }
            
            .toolbar {
                flex-wrap: wrap;
                padding: 5px;
                gap: 5px;
            }
            
            .tool-group {
                padding: 0 5px;
                border-right: none;
                margin-bottom: 5px;
            }
            
            button {
                padding: 6px 8px;
                font-size: 11px;
            }
            
            input[type="range"] {
                width: 60px;
            }
            
            label {
                font-size: 10px;
            }
            
            .timeline {
                min-height: 150px;
                height: 22vh;
            }
            
            .frame {
                width: 50px;
                height: 50px;
            }
            
            .add-frame {
                width: 50px;
                height: 50px;
            }
            
            .layer-name {
                font-size: 10px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                font-size: 10px;
            }
            
            button {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .timeline-layers-section {
                width: 90px;
            }
            
            .timeline {
                min-height: 130px;
                height: 20vh;
            }
            
            .frame {
                width: 40px;
                height: 40px;
            }
            
            .add-frame {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .timeline {
                min-height: 80px;
                height: 25vh;
            }
            
            .toolbar {
                padding: 3px 5px;
            }
            
            button {
                padding: 4px 6px;
            }
        }

        /* Toolbar */
        .toolbar {
            background: #1e1e1e;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #3a3a3a;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid #3a3a3a;
        }

        .tool-group:last-child {
            border-right: none;
        }

        button {
            background: #3a3a3a;
            border: none;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #4a4a4a;
        }

        button.active {
            background: #0066cc;
        }
        
        .dropdown-container {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: #2a2a2a;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            border-radius: 0;
            font-size: 14px;
        }
        
        .dropdown-item:hover {
            background: #3a3a3a;
        }
        
        .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="range"] {
            width: 100px;
        }

        label {
            font-size: 12px;
            margin-right: 5px;
        }

        /* Main content area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Layer items (now in timeline) */
        .layers-list {
            flex: 1;
            overflow-y: auto;
        }

        .layer-item {
            padding: 6px 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border-bottom: 1px solid #2a2a2a;
            font-size: 11px;
            position: relative;
        }
        
        .layer-item.dragging {
            opacity: 0.4;
        }
        
        .layer-item.drop-before::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
        }
        
        .layer-item.drop-after::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
        }
        
        .layer-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .layer-item:hover {
            background: #2a2a2a;
        }

        .layer-item.active {
            background: #0066cc;
        }

        .layer-visibility {
            cursor: pointer;
            font-size: 14px;
        }

        .layer-name {
            flex: 1;
            font-size: 11px;
        }
        
        .layer-opacity-control {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            padding-left: 20px;
        }
        
        .layer-opacity-control input[type="range"] {
            width: 80px;
            height: 3px;
        }
        
        .layer-opacity-value {
            min-width: 28px;
            text-align: right;
            font-size: 10px;
        }

        /* Canvas area */
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #333;
            position: relative;
            overflow: auto;
            min-height: 200px;
        }

        canvas {
            border: 1px solid #555;
            cursor: crosshair;
            max-width: 95%;
            max-height: 95%;
            object-fit: contain;
        }

        #mainCanvas {
            position: relative;
            z-index: 2;
        }

        #onionCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            background: white;
        }
        
        #selectionCanvas {
            position: absolute;
            pointer-events: auto;
            z-index: 3;
        }
        
        .transform-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid #0066cc;
            border-radius: 50%;
            cursor: pointer;
            z-index: 4;
            transform: translate(-50%, -50%);
        }
        
        .transform-handle.corner { cursor: nwse-resize; }
        .transform-handle.side-h { cursor: ew-resize; }
        .transform-handle.side-v { cursor: ns-resize; }
        .transform-handle.rotate { cursor: grab; background: #0066cc; }

        /* Timeline */
        .timeline {
            min-height: 180px;
            max-height: 280px;
            height: 25vh;
            background: #252525;
            border-top: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }
        
        .timeline-header {
            background: #1e1e1e;
            border-bottom: 1px solid #3a3a3a;
        }

        .timeline-controls {
            padding: 8px;
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
        }

        .fps-control {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .timeline-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .timeline-layers-section {
            width: 180px;
            background: #252525;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .layers-header {
            padding: 8px 10px;
            background: #1e1e1e;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .layer-buttons {
            display: flex;
            gap: 4px;
        }
        
        .add-layer-btn-inline {
            padding: 2px 8px;
            font-size: 14px;
            background: #0066cc;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .add-layer-btn-inline:hover {
            background: #0077dd;
        }
        
        .delete-layer-btn-inline {
            padding: 2px 8px;
            font-size: 14px;
            background: #cc3333;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .delete-layer-btn-inline:hover {
            background: #dd4444;
        }
        
        .timeline-layers-section .layers-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .timeline-frames-section {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            background: #2a2a2a;
        }

        .timeline-frames {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .frames-container {
            display: flex;
            padding: 10px;
            gap: 5px;
            min-width: 100%;
        }

        .frame {
            width: 80px;
            height: 80px;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
            cursor: grab;
            position: relative;
            flex-shrink: 0;
            background: #2a2a2a;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .frame:active {
            cursor: grabbing;
        }
        
        .frame.dragging {
            opacity: 0.5;
            transform: scale(1.05);
            cursor: grabbing;
        }
        
        .frame.drag-over {
            border-color: #0066cc;
            background: #1a3a5a;
        }

        .frame:hover {
            border-color: #4a4a4a;
        }

        .frame.active {
            border-color: #0066cc;
        }

        .frame canvas {
            width: 100%;
            height: 100%;
            border: none;
        }

        .frame-number {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 2px;
        }

        .add-frame {
            width: 80px;
            height: 80px;
            border: 2px dashed #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
            flex-shrink: 0;
        }

        .add-frame:hover {
            border-color: #4a4a4a;
            color: #888;
        }
        /* Brush cursor overlay */
        .brush-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            border: 1.5px solid rgba(0, 102, 204, 0.8);
            display: none;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        
        .brush-cursor.round {
            border-radius: 50%;
        }
        
        .brush-cursor.square {
            border-radius: 0;
        }
        
        .brush-cursor.oval-h {
            border-radius: 50%;
        }
        
        .brush-cursor.oval-v {
            border-radius: 50%;
        }
        
        /* Brush/Eraser dropdown panel */
        .brush-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 200px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 10px;
        }
        
        .brush-dropdown.show {
            display: block;
        }
        
        .brush-setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .brush-setting-row:last-child {
            margin-bottom: 0;
        }
        
        .brush-setting-row label {
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .brush-setting-row input[type="range"] {
            width: 80px;
        }
        
        .brush-setting-row select {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            padding: 3px 6px;
            font-size: 12px;
        }
        
        .shape-picker {
            display: flex;
            gap: 4px;
        }
        
        .shape-icon {
            width: 30px;
            height: 30px;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }
        
        .shape-icon:hover {
            border-color: #888;
            background: #444;
        }
        
        .shape-icon.active {
            border-color: #4a9eff;
            background: #2a4a6a;
        }
        
        .shape-icon svg {
            width: 20px;
            height: 20px;
        }
        
        .brush-setting-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: #aaa;
        }

        /* Onion skin dropdown panel */
        .onion-skin-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 220px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 10px;
        }
        
        .onion-skin-dropdown.show {
            display: block;
        }
        
        .onion-setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .onion-setting-row:last-child {
            margin-bottom: 0;
        }
        
        .onion-setting-row label {
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .onion-setting-row input[type="range"] {
            width: 80px;
        }
        
        .onion-setting-row input[type="number"] {
            width: 45px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            padding: 2px 4px;
            font-size: 12px;
        }
        
        .onion-setting-row input[type="color"] {
            width: 28px;
            height: 22px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }
        
        .onion-setting-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: #aaa;
        }
        
        .onion-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 8px 0;
        }

        /* Frame context menu */
        .frame-context-menu {
            display: none;
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 160px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 4px 0;
        }
        
        .frame-context-menu.show {
            display: block;
        }
        
        .frame-context-menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 8px 14px;
            background: none;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
        }
        
        .frame-context-menu-item:hover {
            background: #3a3a3a;
        }
        
        .frame-context-menu-item.disabled {
            color: #666;
            cursor: default;
        }
        
        .frame-context-menu-item.disabled:hover {
            background: none;
        }
        
        .frame-context-menu-item .shortcut {
            font-size: 11px;
            color: #888;
            margin-left: 16px;
        }
        
        .frame-context-menu-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="brushTool" class="active" title="Brush">üñåÔ∏è Brush ‚ñº</button>
                    <div class="brush-dropdown" id="brushDropdown">
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="brushShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="brushDiameter" min="1" max="100" value="5">
                            <span class="brush-setting-value" id="brushDiameterValue">5</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="brushSmoothing" min="0" max="100" value="0">
                            <span class="brush-setting-value" id="brushSmoothingValue">0%</span>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="eraserTool" title="Eraser">üßπ Eraser ‚ñº</button>
                    <div class="brush-dropdown" id="eraserDropdown">
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="eraserShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="eraserDiameter" min="1" max="100" value="5">
                            <span class="brush-setting-value" id="eraserDiameterValue">5</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="eraserSmoothing" min="0" max="100" value="0">
                            <span class="brush-setting-value" id="eraserSmoothingValue">0%</span>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="shapeTool" title="Shapes">üìê Shapes ‚ñº</button>
                    <div class="dropdown-menu" id="shapeDropdown">
                        <button class="dropdown-item" data-shape="line">üìè Line</button>
                        <button class="dropdown-item" data-shape="rect">‚¨ú Rectangle</button>
                        <button class="dropdown-item" data-shape="circle">‚≠ï Circle</button>
                        <button class="dropdown-item" data-shape="triangle">üî∫ Triangle</button>
                    </div>
                </div>
                <button id="fillTool" title="Fill Bucket">ü™£ Fill</button>
                <button id="lassoTool" title="Lasso Selection">üéØ Lasso</button>
                <button id="transformTool" title="Free Transform">üîÑ Transform</button>
            </div>
            <div class="tool-group">
                <label>Color:</label>
                <input type="color" id="colorPicker" value="#000000">
                <label>Size:</label>
                <input type="range" id="brushSize" min="1" max="100" value="5">
                <span id="sizeValue">5</span>
            </div>
            <div class="tool-group">
                <button id="copyBtn" title="Copy selection or frame (Ctrl+C)">üìã Copy</button>
                <button id="pasteBtn" title="Paste (Ctrl+V)">üìå Paste</button>
                <button id="pasteInPlaceBtn" title="Paste in Place (Ctrl+Shift+V)">üìç Paste in Place</button>
                <div class="dropdown-container">
                    <button id="onionSkinToggle">üëÅÔ∏è Onion Skin ‚ñº</button>
                    <div class="onion-skin-dropdown" id="onionSkinDropdown">
                        <div class="onion-setting-row">
                            <label>Enabled:</label>
                            <input type="checkbox" id="onionEnabled" checked>
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Opacity:</label>
                            <input type="range" id="onionOpacity" min="5" max="80" value="30">
                            <span class="onion-setting-value" id="onionOpacityValue">30%</span>
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Frames Before:</label>
                            <input type="number" id="onionFramesBefore" min="0" max="10" value="1">
                        </div>
                        <div class="onion-setting-row">
                            <label>Previous Color:</label>
                            <input type="color" id="onionPrevColor" value="#ff0000">
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Frames After:</label>
                            <input type="number" id="onionFramesAfter" min="0" max="10" value="1">
                        </div>
                        <div class="onion-setting-row">
                            <label>Next Color:</label>
                            <input type="color" id="onionNextColor" value="#00cc00">
                        </div>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <button id="undoBtn">‚Ü∂ Undo</button>
                <button id="redoBtn">‚Ü∑ Redo</button>
            </div>
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="exportBtn">üì¶ Export ‚ñº</button>
                    <div class="dropdown-menu" id="exportDropdown">
                        <button class="dropdown-item" id="exportPngZip">PNG Frames (ZIP)</button>
                        <button class="dropdown-item" id="exportGifBtn">GIF Animation</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <!-- Canvas area -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="onionCanvas" width="960" height="540"></canvas>
                <canvas id="mainCanvas" width="960" height="540"></canvas>
                <canvas id="selectionCanvas" width="960" height="540"></canvas>
                <div class="brush-cursor" id="brushCursor"></div>
            </div>
        </div>

        <!-- Combined Timeline & Layers Panel -->
        <div class="timeline">
            <div class="timeline-header">
                <div class="timeline-controls">
                    <div class="playback-controls">
                        <button id="playBtn">‚ñ∂Ô∏è Play</button>
                        <button id="stopBtn">‚èπÔ∏è Stop</button>
                        <button id="prevFrame">‚óÄÔ∏è</button>
                        <button id="nextFrame">‚ñ∂Ô∏è</button>
                        <button id="insertFrame">+ Insert Frame</button>
                        <button id="duplicateFrame">‚ßâ Duplicate Frame</button>
                        <button id="clearFrame">üßΩ Clear Frame</button>
                        <button id="deleteFrame">üóëÔ∏è Delete Frame</button>
                    </div>
                    <div class="fps-control">
                        <label>FPS:</label>
                        <input type="number" id="fpsInput" min="1" max="60" value="12" style="width: 50px;">
                    </div>
                </div>
            </div>
            <div class="timeline-body">
                <div class="timeline-layers-section">
                    <div class="layers-header">
                        <span>Layers</span>
                        <div class="layer-buttons">
                            <button class="add-layer-btn-inline" id="addLayerBtn" title="Add Layer">+</button>
                            <button class="add-layer-btn-inline" id="duplicateLayerBtn" title="Duplicate Layer">‚ßâ</button>
                            <button class="delete-layer-btn-inline" id="deleteLayerBtn" title="Delete Layer">-</button>
                        </div>
                    </div>
                    <div class="layers-list" id="layersList"></div>
                </div>
                <div class="timeline-frames-section">
                    <div class="frames-container" id="framesContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Frame context menu -->
    <div class="frame-context-menu" id="frameContextMenu">
        <button class="frame-context-menu-item" id="ctxCopyFrame">üìã Copy Frame<span class="shortcut">Ctrl+C</span></button>
        <button class="frame-context-menu-item" id="ctxPasteFrame">üìå Paste Frame<span class="shortcut">Ctrl+V</span></button>
        <div class="frame-context-menu-divider"></div>
        <button class="frame-context-menu-item" id="ctxDuplicateFrame">‚ú® Duplicate Frame<span class="shortcut">Ctrl+D</span></button>
    </div>

    <script>
        // Animation Studio App
        class AnimationStudio {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.onionCanvas = document.getElementById('onionCanvas');
                this.onionCtx = this.onionCanvas.getContext('2d');
                this.selectionCanvas = document.getElementById('selectionCanvas');
                this.selectionCtx = this.selectionCanvas.getContext('2d');
                this.brushCursor = document.getElementById('brushCursor');
                
                this.layers = [{ id: 1, name: 'Layer 1', visible: true, opacity: 1.0, frames: [] }];
                this.currentLayerId = 1;
                this.currentFrameIndex = 0;
                this.nextLayerId = 2;
                
                this.tool = 'brush';
                this.color = '#000000';
                this.brushSize = 5;
                this.brushShape = 'round';    // 'round', 'square', 'oval-h', 'oval-v'
                this.eraserShape = 'round';
                this.brushSmoothing = 0;      // 0-100
                this.eraserSmoothing = 0;
                this.smoothPoints = [];       // Buffer for smoothing
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.onionSkinEnabled = true;
                this.onionSkinOpacity = 0.30;
                this.onionFramesBefore = 1;
                this.onionFramesAfter = 1;
                this.onionPrevColor = '#ff0000';
                this.onionNextColor = '#00cc00';
                this.isPlaying = false;
                this.fps = 12;
                this.playbackInterval = null;
                
                this.shapeStart = null;
                
                // Undo/Redo stacks
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistorySize = 50;
                
                // Drag and drop properties
                this.draggedFrameIndex = null;
                this.dropTargetIndex = null;
                this.draggedLayerId = null;
                this.dropTargetLayerId = null;
                this.dropPosition = null; // 'before' or 'after'
                
                // Lasso and selection properties
                this.lassoPath = [];
                this.selection = null; // {imageData, bounds: {x, y, width, height}}
                this.isTransforming = false;
                this.isRotating = false;
                this.rotationMode = false; // Track if we're in rotation mode
                this.hoverHandle = null; // Track which handle is being hovered
                this.hoverTimer = null; // Timer for hover detection
                this.transformHandles = [];
                this.activeHandle = null;
                this.transformStart = null;
                
                // Clipboard properties
                this.copiedSelection = null; // For selection copy/paste
                this.copiedFrame = null; // For frame copy/paste
                this.contextMenuFrameIndex = null; // Track which frame was right-clicked
                
                this.initializeFrame();
                this.setupEventListeners();
                this.updateUndoRedoButtons();
                this.positionOnionCanvas();
                this.render();
                
                // Set initial cursor for brush tool
                this.canvas.style.cursor = 'none';
                this.selectionCanvas.style.cursor = 'none';
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.positionOnionCanvas();
                    this.render();
                });
            }
            
            positionOnionCanvas() {
                // Position onion canvas and selection canvas to match main canvas
                const mainRect = this.canvas.getBoundingClientRect();
                const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();
                
                const left = (mainRect.left - containerRect.left) + 'px';
                const top = (mainRect.top - containerRect.top) + 'px';
                
                this.onionCanvas.style.left = left;
                this.onionCanvas.style.top = top;
                this.selectionCanvas.style.left = left;
                this.selectionCanvas.style.top = top;
            }
            
            initializeFrame() {
                const layer = this.getCurrentLayer();
                if (!layer.frames[this.currentFrameIndex]) {
                    layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                }
            }
            
            createEmptyFrame() {
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = this.canvas.width;
                frameCanvas.height = this.canvas.height;
                return frameCanvas;
            }
            
            getCurrentLayer() {
                return this.layers.find(l => l.id === this.currentLayerId);
            }
            
            setupEventListeners() {
                // Drawing events - Mouse
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());
                
                // Drawing events - Touch (iPad/Apple Pencil)
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
                
                // Selection canvas events for transform tool
                this.selectionCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.selectionCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.selectionCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.selectionCanvas.addEventListener('mouseout', () => this.stopDrawing());
                
                this.selectionCanvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.selectionCanvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.selectionCanvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.selectionCanvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
                
                // Prevent default touch behavior
                this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                this.selectionCanvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.selectionCanvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                
                // Tool selection
                const brushBtn = document.getElementById('brushTool');
                const brushDropdown = document.getElementById('brushDropdown');
                const eraserBtn = document.getElementById('eraserTool');
                const eraserDropdown = document.getElementById('eraserDropdown');
                
                brushBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'brush') {
                        brushDropdown.classList.toggle('show');
                        eraserDropdown.classList.remove('show');
                    } else {
                        this.selectTool('brush');
                        brushDropdown.classList.remove('show');
                    }
                });
                
                eraserBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'eraser') {
                        eraserDropdown.classList.toggle('show');
                        brushDropdown.classList.remove('show');
                    } else {
                        this.selectTool('eraser');
                        eraserDropdown.classList.remove('show');
                    }
                });
                
                // Prevent dropdown clicks from propagating
                brushDropdown.addEventListener('click', (e) => e.stopPropagation());
                eraserDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                // Brush dropdown controls
                document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.brushShape = icon.dataset.shape;
                        document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('brushDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('brushSmoothing').addEventListener('input', (e) => {
                    this.brushSmoothing = parseInt(e.target.value);
                    document.getElementById('brushSmoothingValue').textContent = e.target.value + '%';
                });
                
                // Eraser dropdown controls
                document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.eraserShape = icon.dataset.shape;
                        document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('eraserDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('eraserSmoothing').addEventListener('input', (e) => {
                    this.eraserSmoothing = parseInt(e.target.value);
                    document.getElementById('eraserSmoothingValue').textContent = e.target.value + '%';
                });

                document.getElementById('fillTool').addEventListener('click', () => this.selectTool('fill'));
                document.getElementById('lassoTool').addEventListener('click', () => this.selectTool('lasso'));
                document.getElementById('transformTool').addEventListener('click', () => this.selectTool('transform'));
                
                // Brush cursor tracking
                const canvasContainer = document.getElementById('canvasContainer');
                canvasContainer.addEventListener('mousemove', (e) => {
                    if (this.tool === 'brush' || this.tool === 'eraser') {
                        this.brushCursor.style.display = 'block';
                        this.brushCursor.style.left = e.clientX + 'px';
                        this.brushCursor.style.top = e.clientY + 'px';
                        this.updateBrushCursor();
                    }
                });
                canvasContainer.addEventListener('mouseleave', () => {
                    this.brushCursor.style.display = 'none';
                });
                
                // Shapes dropdown
                const shapeButton = document.getElementById('shapeTool');
                const shapeDropdown = document.getElementById('shapeDropdown');
                
                shapeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    shapeDropdown.classList.toggle('show');
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', () => {
                    shapeDropdown.classList.remove('show');
                    onionDropdown.classList.remove('show');
                    brushDropdown.classList.remove('show');
                    eraserDropdown.classList.remove('show');
                });
                
                // Shape selection
                shapeDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const shape = item.getAttribute('data-shape');
                        this.selectTool(shape);
                        shapeDropdown.classList.remove('show');
                        
                        // Update button text to show selected shape
                        const icons = {
                            'line': 'üìè',
                            'rect': '‚¨ú',
                            'circle': '‚≠ï',
                            'triangle': 'üî∫'
                        };
                        shapeButton.innerHTML = `${icons[shape]} ${item.textContent.split(' ')[1]} ‚ñº`;
                    });
                });
                
                // Color and size
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.color = e.target.value;
                });
                
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.syncBrushSizeUI();
                    this.updateBrushCursor();
                });
                
                // Frame controls
                document.getElementById('clearFrame').addEventListener('click', () => this.clearCurrentFrame());
                
                // Onion skin dropdown
                const onionBtn = document.getElementById('onionSkinToggle');
                const onionDropdown = document.getElementById('onionSkinDropdown');
                onionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onionDropdown.classList.toggle('show');
                });
                onionDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                document.getElementById('onionEnabled').addEventListener('change', (e) => {
                    this.onionSkinEnabled = e.target.checked;
                    onionBtn.style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                    this.render();
                });
                document.getElementById('onionOpacity').addEventListener('input', (e) => {
                    this.onionSkinOpacity = parseInt(e.target.value) / 100;
                    document.getElementById('onionOpacityValue').textContent = e.target.value + '%';
                    this.render();
                });
                document.getElementById('onionFramesBefore').addEventListener('change', (e) => {
                    this.onionFramesBefore = parseInt(e.target.value);
                    this.render();
                });
                document.getElementById('onionFramesAfter').addEventListener('change', (e) => {
                    this.onionFramesAfter = parseInt(e.target.value);
                    this.render();
                });
                document.getElementById('onionPrevColor').addEventListener('input', (e) => {
                    this.onionPrevColor = e.target.value;
                    this.render();
                });
                document.getElementById('onionNextColor').addEventListener('input', (e) => {
                    this.onionNextColor = e.target.value;
                    this.render();
                });
                
                // Copy/Paste buttons
                document.getElementById('copyBtn').addEventListener('click', () => {
                    if (this.selection) {
                        this.copySelection();
                    } else {
                        this.copyFrame();
                    }
                });
                document.getElementById('pasteBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelection();
                    } else if (this.copiedFrame) {
                        this.pasteFrame();
                    }
                });
                document.getElementById('pasteInPlaceBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelectionInPlace();
                    }
                });
                
                // Undo/Redo controls
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                
                // Keyboard shortcuts for undo/redo
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        this.redo();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        if (this.selection) {
                            this.copySelection();
                        } else {
                            this.copyFrame();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'v' || e.key === 'V')) {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelectionInPlace();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelection();
                        } else if (this.copiedFrame) {
                            this.pasteFrame();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        this.duplicateFrame();
                    } else if (e.key === 'Enter' && this.selection) {
                        e.preventDefault();
                        this.applySelection();
                        this.clearSelection();
                        this.selectTool('brush');
                    } else if (e.key === 'Escape' && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.selectTool('brush');
                        this.render();
                    } else if ((e.key === 'Delete' || e.key === 'Backspace') && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.render();
                    }
                    
                    // Single-key shortcuts (only when no modifier keys held)
                    if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                        switch (e.key) {
                            case 'b':
                                e.preventDefault();
                                this.selectTool('brush');
                                break;
                            case 'e':
                                e.preventDefault();
                                this.selectTool('eraser');
                                break;
                            case 'f':
                                e.preventDefault();
                                this.selectTool('fill');
                                break;
                            case 'l':
                                e.preventDefault();
                                this.selectTool('lasso');
                                break;
                            case 'v':
                                e.preventDefault();
                                this.selectTool('transform');
                                break;
                            case '[':
                                e.preventDefault();
                                this.brushSize = Math.max(1, this.brushSize - 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case ']':
                                e.preventDefault();
                                this.brushSize = Math.min(100, this.brushSize + 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case 'F5':
                                e.preventDefault();
                                this.duplicateFrame();
                                break;
                            case 'F6':
                                e.preventDefault();
                                this.insertFrameAfterCurrent();
                                break;
                            case 'F7':
                                e.preventDefault();
                                this.deleteCurrentFrame();
                                break;
                            case 'Backspace':
                                if (!this.selection) {
                                    e.preventDefault();
                                    this.clearCurrentFrame();
                                }
                                break;
                            case ' ':
                                e.preventDefault();
                                if (this.isPlaying) {
                                    this.stop();
                                } else {
                                    this.play();
                                }
                                break;
                            case ',':
                                e.preventDefault();
                                this.previousFrame();
                                break;
                            case '.':
                                e.preventDefault();
                                this.goToNextFrame();
                                break;
                        }
                    }
                });
                
                // Playback controls
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('prevFrame').addEventListener('click', () => this.previousFrame());
                document.getElementById('nextFrame').addEventListener('click', () => this.nextFrame());
                document.getElementById('insertFrame').addEventListener('click', () => this.insertFrameAfterCurrent());
                document.getElementById('duplicateFrame').addEventListener('click', () => this.duplicateFrame());
                document.getElementById('deleteFrame').addEventListener('click', () => this.deleteCurrentFrame());
                document.getElementById('fpsInput').addEventListener('change', (e) => {
                    this.fps = parseInt(e.target.value);
                });
                
                // Frame context menu
                const ctxMenu = document.getElementById('frameContextMenu');
                document.getElementById('ctxCopyFrame').addEventListener('click', () => {
                    this.copyFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxPasteFrame').addEventListener('click', () => {
                    if (this.copiedFrame) {
                        this.pasteFrame(this.contextMenuFrameIndex);
                    }
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxDuplicateFrame').addEventListener('click', () => {
                    this.duplicateFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                
                // Close context menu on click outside
                document.addEventListener('click', () => {
                    ctxMenu.classList.remove('show');
                });
                
                // Layer controls
                document.getElementById('addLayerBtn').addEventListener('click', () => this.addLayer());
                document.getElementById('duplicateLayerBtn').addEventListener('click', () => this.duplicateLayer());
                document.getElementById('deleteLayerBtn').addEventListener('click', () => this.deleteLayer());
                
                // Export
                // Export dropdown
                const exportBtn = document.getElementById('exportBtn');
                const exportDropdown = document.getElementById('exportDropdown');
                exportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    exportDropdown.classList.toggle('show');
                });
                document.getElementById('exportPngZip').addEventListener('click', () => {
                    exportDropdown.classList.remove('show');
                    this.exportGif();
                });
                document.getElementById('exportGifBtn').addEventListener('click', () => {
                    exportDropdown.classList.remove('show');
                    this.exportAsGif();
                });
            }
            
            selectTool(tool) {
                this.tool = tool;
                document.querySelectorAll('.toolbar button').forEach(btn => btn.classList.remove('active'));
                const toolButton = document.getElementById(tool + 'Tool');
                if (toolButton) toolButton.classList.add('active');
                
                // Clear selection when switching away from transform
                if (tool !== 'transform' && this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                // Show transform handles if tool is transform and selection exists
                if (tool === 'transform' && this.selection) {
                    this.showTransformHandles();
                } else if (tool === 'transform' && !this.selection) {
                    // Auto-select all content in the current frame
                    this.selectAllInFrame();
                } else {
                    this.hideTransformHandles();
                }
                
                // Manage brush cursor visibility and canvas default cursor
                if (tool === 'brush' || tool === 'eraser') {
                    this.canvas.style.cursor = 'none';
                    this.selectionCanvas.style.cursor = 'none';
                } else {
                    this.canvas.style.cursor = 'crosshair';
                    this.selectionCanvas.style.cursor = 'default';
                    this.brushCursor.style.display = 'none';
                }
            }
            
            updateBrushCursor() {
                const shape = this.tool === 'eraser' ? this.eraserShape : this.brushShape;
                const rect = this.canvas.getBoundingClientRect();
                const displayScale = rect.width / this.canvas.width;
                const size = Math.max(2, this.brushSize * displayScale);
                
                let w = size, h = size;
                if (shape === 'oval-h') {
                    w = size;
                    h = size * 0.4;
                } else if (shape === 'oval-v') {
                    w = size * 0.4;
                    h = size;
                }
                
                this.brushCursor.style.width = w + 'px';
                this.brushCursor.style.height = h + 'px';
                this.brushCursor.className = 'brush-cursor ' + shape;
            }
            
            syncBrushSizeUI() {
                // Sync the dropdown diameter sliders with the current brushSize
                if (this.tool === 'brush') {
                    document.getElementById('brushDiameter').value = this.brushSize;
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                } else if (this.tool === 'eraser') {
                    document.getElementById('eraserDiameter').value = this.brushSize;
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                }
            }
            
            getCurrentBrushShape() {
                return this.tool === 'eraser' ? this.eraserShape : this.brushShape;
            }
            
            getSmoothing() {
                return this.tool === 'eraser' ? this.eraserSmoothing : this.brushSmoothing;
            }
            
            selectAllInFrame() {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame) return;
                
                const frameCtx = frame.getContext('2d');
                const pixelData = frameCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = pixelData.data;
                
                // Find tight bounding box of non-transparent pixels
                let minX = frame.width, minY = frame.height, maxX = -1, maxY = -1;
                
                for (let py = 0; py < frame.height; py++) {
                    for (let px = 0; px < frame.width; px++) {
                        const alpha = pixels[(py * frame.width + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < minX) minX = px;
                            if (px > maxX) maxX = px;
                            if (py < minY) minY = py;
                            if (py > maxY) maxY = py;
                        }
                    }
                }
                
                // Nothing on the frame
                if (maxX < 0 || maxY < 0) {
                    this.hideTransformHandles();
                    return;
                }
                
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                
                // Create selection canvas with the content
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = width;
                selectedCanvas.height = height;
                const selectedCtx = selectedCanvas.getContext('2d');
                selectedCtx.drawImage(frame, minX, minY, width, height, 0, 0, width, height);
                
                // Store selection
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: minX, y: minY, width, height },
                    originalBounds: { x: minX, y: minY, width, height }
                };
                
                // Erase content from original frame
                this.saveState();
                frameCtx.clearRect(0, 0, frame.width, frame.height);
                
                this.showTransformHandles();
                this.render();
            }
            
            saveState() {
                // Create a deep copy of the entire application state
                const state = {
                    layers: this.layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        frames: layer.frames.map(frame => {
                            if (!frame) return null;
                            const frameCopy = document.createElement('canvas');
                            frameCopy.width = frame.width;
                            frameCopy.height = frame.height;
                            const copyCtx = frameCopy.getContext('2d');
                            copyCtx.drawImage(frame, 0, 0);
                            return frameCopy;
                        })
                    })),
                    currentLayerId: this.currentLayerId,
                    currentFrameIndex: this.currentFrameIndex,
                    nextLayerId: this.nextLayerId
                };
                
                this.undoStack.push(state);
                
                // Limit history size
                if (this.undoStack.length > this.maxHistorySize) {
                    this.undoStack.shift();
                }
                
                // Clear redo stack when new action is performed
                this.redoStack = [];
                
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (this.undoStack.length === 0) return;
                
                // Save current state to redo stack before undoing
                const currentState = {
                    layers: this.layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        frames: layer.frames.map(frame => {
                            if (!frame) return null;
                            const frameCopy = document.createElement('canvas');
                            frameCopy.width = frame.width;
                            frameCopy.height = frame.height;
                            const copyCtx = frameCopy.getContext('2d');
                            copyCtx.drawImage(frame, 0, 0);
                            return frameCopy;
                        })
                    })),
                    currentLayerId: this.currentLayerId,
                    currentFrameIndex: this.currentFrameIndex,
                    nextLayerId: this.nextLayerId
                };
                
                this.redoStack.push(currentState);
                
                // Restore previous state
                const previousState = this.undoStack.pop();
                this.restoreState(previousState);
                
                this.updateUndoRedoButtons();
            }
            
            redo() {
                if (this.redoStack.length === 0) return;
                
                // Save current state to undo stack before redoing
                const currentState = {
                    layers: this.layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        frames: layer.frames.map(frame => {
                            if (!frame) return null;
                            const frameCopy = document.createElement('canvas');
                            frameCopy.width = frame.width;
                            frameCopy.height = frame.height;
                            const copyCtx = frameCopy.getContext('2d');
                            copyCtx.drawImage(frame, 0, 0);
                            return frameCopy;
                        })
                    })),
                    currentLayerId: this.currentLayerId,
                    currentFrameIndex: this.currentFrameIndex,
                    nextLayerId: this.nextLayerId
                };
                
                this.undoStack.push(currentState);
                
                // Restore redo state
                const redoState = this.redoStack.pop();
                this.restoreState(redoState);
                
                this.updateUndoRedoButtons();
            }
            
            restoreState(state) {
                // Restore layers
                this.layers = state.layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    frames: layer.frames.map(frame => {
                        if (!frame) return null;
                        const frameCopy = document.createElement('canvas');
                        frameCopy.width = frame.width;
                        frameCopy.height = frame.height;
                        const copyCtx = frameCopy.getContext('2d');
                        copyCtx.drawImage(frame, 0, 0);
                        return frameCopy;
                    })
                }));
                
                // Restore current state
                this.currentLayerId = state.currentLayerId;
                this.currentFrameIndex = state.currentFrameIndex;
                this.nextLayerId = state.nextLayerId;
                
                this.renderLayers();
                this.render();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                undoBtn.disabled = this.undoStack.length === 0;
                redoBtn.disabled = this.redoStack.length === 0;
                
                undoBtn.style.opacity = this.undoStack.length === 0 ? '0.5' : '1';
                redoBtn.style.opacity = this.redoStack.length === 0 ? '0.5' : '1';
            }
            
            startDrawing(e) {
                // Handle fill tool
                if (this.tool === 'fill') {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = Math.floor((e.clientX - rect.left) * scaleX);
                    const y = Math.floor((e.clientY - rect.top) * scaleY);
                    this.floodFill(x, y);
                    return;
                }
                
                // Handle lasso tool differently
                if (this.tool === 'lasso') {
                    this.lassoPath = [];
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    this.lassoPath.push({x, y});
                    this.isDrawing = true;
                    return;
                }
                
                // Handle transform tool
                if (this.tool === 'transform') {
                    // Check if clicking on a handle
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    for (let handle of this.transformHandles) {
                        const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                        if (dist < 15) { // Increased hit area for touch
                            // Check if we're in rotation mode and this is a corner
                            const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                           handle.type === 'se' || handle.type === 'sw';
                            
                            if (this.rotationMode && isCorner) {
                                // Enter rotation mode
                                this.activeHandle = {type: 'rotate', corner: handle.type};
                                this.isRotating = true;
                                this.initialRotation = this.selection.rotation || 0;
                                // Calculate initial angle from anchor to click point
                                const anchorX = this.selection.anchorX;
                                const anchorY = this.selection.anchorY;
                                this.startAngle = Math.atan2(y - anchorY, x - anchorX);
                                this.updateRotationCursor(handle.type, true);
                            } else {
                                // Normal resize/transform mode
                                this.activeHandle = handle;
                            }
                            
                            this.transformStart = {x, y};
                            this.isTransforming = true;
                            return;
                        }
                    }
                    
                    // Check if clicking inside selection to move it
                    if (this.selection && this.isPointInSelection(x, y)) {
                        this.activeHandle = {type: 'move'};
                        this.transformStart = {x, y};
                        this.isTransforming = true;
                        return;
                    }
                    
                    // Clicked outside selection ‚Äî apply and deselect
                    if (this.selection) {
                        this.applySelection();
                        this.clearSelection();
                        this.selectTool('brush');
                        this.render();
                    }
                    return;
                }
                
                // Save state before starting to draw
                this.saveState();
                
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                this.lastX = (e.clientX - rect.left) * scaleX;
                this.lastY = (e.clientY - rect.top) * scaleY;
                this.shapeStart = { x: this.lastX, y: this.lastY };
                this.smoothX = this.lastX;
                this.smoothY = this.lastY;
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    this.drawPoint(this.lastX, this.lastY);
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                
                // Get the actual canvas that was touched
                const targetCanvas = e.currentTarget;
                
                // Create a synthetic mouse event with the correct target
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    target: targetCanvas
                };
                
                this.startDrawing(mouseEvent);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                if (!this.isDrawing && !this.isTransforming) return;
                
                const touch = e.touches[0];
                
                // Get the actual canvas that was touched
                const targetCanvas = e.currentTarget;
                
                // Create a synthetic mouse event with the correct target
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    target: targetCanvas
                };
                
                this.draw(mouseEvent);
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                this.stopDrawing();
            }
            
            draw(e) {
                // Handle hover detection for rotation mode (when not actively transforming)
                if (this.tool === 'transform' && this.selection && !this.isDrawing && !this.isTransforming) {
                    this.checkRotationHover(e);
                }
                
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Store last mouse event for shape finalization
                window.lastMouseEvent = e;
                
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Handle lasso
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.lassoPath.push({x, y});
                    this.drawLassoPath();
                    return;
                }
                
                // Handle transform
                if (this.tool === 'transform' && this.isTransforming) {
                    this.performTransform(x, y);
                    return;
                }
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    const smoothing = this.getSmoothing();
                    if (smoothing > 0) {
                        // Exponential smoothing: higher smoothing = slower catch-up
                        const factor = 1 - (smoothing / 100) * 0.95;
                        this.smoothX += (x - this.smoothX) * factor;
                        this.smoothY += (y - this.smoothY) * factor;
                        this.drawLine(this.lastX, this.lastY, this.smoothX, this.smoothY);
                        this.lastX = this.smoothX;
                        this.lastY = this.smoothY;
                    } else {
                        this.drawLine(this.lastX, this.lastY, x, y);
                        this.lastX = x;
                        this.lastY = y;
                    }
                } else {
                    // Preview shape
                    this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, true);
                }
            }
            
            checkRotationHover(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Check if hovering near a corner handle
                let nearCorner = false;
                let hoveredHandle = null;
                
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    
                    const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                     handle.type === 'se' || handle.type === 'sw';
                    
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    
                    // Larger hover area for rotation detection (20px)
                    if (dist < 20 && isCorner) {
                        nearCorner = true;
                        hoveredHandle = handle;
                        break;
                    }
                }
                
                // Set up hover timer for rotation mode
                if (nearCorner) {
                    // If we're hovering and don't have a timer running, start one
                    if (!this.hoverTimer) {
                        this.hoverHandle = hoveredHandle;
                        
                        // After 500ms of hovering, switch to rotation mode
                        this.hoverTimer = setTimeout(() => {
                            this.rotationMode = true;
                            // Create custom cursor with rotation arrow based on corner
                            this.updateRotationCursor(hoveredHandle.type);
                            this.hoverTimer = null; // Clear timer reference
                        }, 500);
                    }
                } else if (!nearCorner) {
                    // Clear hover state when not near any corner
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.rotationMode = false;
                    this.selectionCanvas.style.cursor = 'default';
                }
            }
            
            updateRotationCursor(cornerType, isActive = false) {
                // Create SVG cursor with rotation arrow based on corner position
                let arrow, rotation;
                
                // Determine which arrow and rotation based on corner
                switch(cornerType) {
                    case 'nw': // Top-left: counter-clockwise arrow
                        arrow = '‚Ü∂';
                        rotation = 0;
                        break;
                    case 'ne': // Top-right: clockwise arrow
                        arrow = '‚Ü∑';
                        rotation = 0;
                        break;
                    case 'se': // Bottom-right: counter-clockwise arrow
                        arrow = '‚Ü∂';
                        rotation = 180;
                        break;
                    case 'sw': // Bottom-left: clockwise arrow
                        arrow = '‚Ü∑';
                        rotation = 180;
                        break;
                    default:
                        arrow = '‚Üª';
                        rotation = 0;
                }
                
                // Create SVG cursor with visible dark colors
                const svg = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
                        <text x="16" y="20" font-size="26" text-anchor="middle" 
                              transform="rotate(${rotation}, 16, 16)"
                              fill="${isActive ? '#0066cc' : '#222'}" 
                              stroke="#000" 
                              stroke-width="0.5"
                              paint-order="stroke">${arrow}</text>
                    </svg>
                `;
                
                const encodedSvg = encodeURIComponent(svg);
                this.selectionCanvas.style.cursor = `url('data:image/svg+xml;utf8,${encodedSvg}') 16 16, pointer`;
            }
            
            stopDrawing() {
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Handle lasso completion
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.isDrawing = false;
                    this.completeLassoSelection();
                    return;
                }
                
                // Handle transform completion
                if (this.tool === 'transform' && this.isTransforming) {
                    this.isTransforming = false;
                    this.isRotating = false;
                    this.rotationMode = false; // Reset so next hover can activate
                    this.activeHandle = null;
                    this.transformStart = null;
                    // Clear the timer too
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.selectionCanvas.style.cursor = 'default';
                    this.render();
                    return;
                }
                
                if (['line', 'rect', 'circle', 'triangle'].includes(this.tool) && this.shapeStart) {
                    // Get current mouse position from last draw
                    const rect = this.canvas.getBoundingClientRect();
                    // Finalize shape by drawing it to the frame
                    const mouseEvent = window.lastMouseEvent;
                    if (mouseEvent) {
                        const x = mouseEvent.clientX - rect.left;
                        const y = mouseEvent.clientY - rect.top;
                        this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, false);
                    }
                }
                
                this.isDrawing = false;
                this.shapeStart = null;
                this.render();
            }
            
            drawPoint(x, y) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this.getCurrentBrushShape();
                const radius = this.brushSize / 2;
                
                frameCtx.globalCompositeOperation = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                frameCtx.fillStyle = this.color;
                if (shape === 'square') {
                    frameCtx.fillRect(x - radius, y - radius, this.brushSize, this.brushSize);
                } else if (shape === 'oval-h') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else if (shape === 'oval-v') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else {
                    frameCtx.beginPath();
                    frameCtx.arc(x, y, radius, 0, Math.PI * 2);
                    frameCtx.fill();
                }
                frameCtx.globalCompositeOperation = 'source-over';
                
                // Also draw directly to main canvas for immediate feedback
                this.ctx.globalCompositeOperation = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                this.ctx.fillStyle = this.color;
                if (shape === 'square') {
                    this.ctx.fillRect(x - radius, y - radius, this.brushSize, this.brushSize);
                } else if (shape === 'oval-h') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (shape === 'oval-v') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalCompositeOperation = 'source-over';
            }
            
            drawLine(x1, y1, x2, y2) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this.getCurrentBrushShape();
                
                if (shape === 'oval-h' || shape === 'oval-v') {
                    // Stamp ellipses along the line path
                    const rx = shape === 'oval-h' ? this.brushSize / 2 : this.brushSize * 0.2;
                    const ry = shape === 'oval-v' ? this.brushSize / 2 : this.brushSize * 0.2;
                    const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const step = Math.max(1, Math.min(rx, ry) * 0.3);
                    const steps = Math.max(1, Math.ceil(dist / step));
                    
                    const compositeOp = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                    
                    for (const ctx of [frameCtx, this.ctx]) {
                        ctx.globalCompositeOperation = compositeOp;
                        ctx.fillStyle = this.color;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const px = x1 + (x2 - x1) * t;
                            const py = y1 + (y2 - y1) * t;
                            ctx.beginPath();
                            ctx.ellipse(px, py, rx, ry, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalCompositeOperation = 'source-over';
                    }
                } else {
                    const cap = shape === 'square' ? 'square' : 'round';
                    const join = shape === 'square' ? 'miter' : 'round';
                    const compositeOp = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                    
                    for (const ctx of [frameCtx, this.ctx]) {
                        ctx.globalCompositeOperation = compositeOp;
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = this.brushSize;
                        ctx.lineCap = cap;
                        ctx.lineJoin = join;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.globalCompositeOperation = 'source-over';
                    }
                }
            }
            
            drawShape(x1, y1, x2, y2, preview = false) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                
                const drawTriangle = (ctx) => {
                    const midX = (x1 + x2) / 2;
                    ctx.beginPath();
                    ctx.moveTo(midX, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x1, y2);
                    ctx.closePath();
                    ctx.stroke();
                };
                
                if (preview) {
                    // Clear and redraw everything for preview
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw all visible layers
                    for (const l of this.layers) {
                        if (l.visible && l.frames[this.currentFrameIndex]) {
                            this.ctx.drawImage(l.frames[this.currentFrameIndex], 0, 0);
                        }
                    }
                    
                    // Now draw the preview shape on top
                    this.ctx.strokeStyle = this.color;
                    this.ctx.lineWidth = this.brushSize;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.globalCompositeOperation = 'source-over';
                    
                    if (this.tool === 'line') {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    } else if (this.tool === 'rect') {
                        this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    } else if (this.tool === 'circle') {
                        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        this.ctx.beginPath();
                        this.ctx.arc(x1, y1, radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else if (this.tool === 'triangle') {
                        drawTriangle(this.ctx);
                    }
                } else {
                    // Draw final shape to frame
                    const frameCtx = frame.getContext('2d');
                    frameCtx.strokeStyle = this.color;
                    frameCtx.lineWidth = this.brushSize;
                    frameCtx.lineCap = 'round';
                    frameCtx.lineJoin = 'round';
                    frameCtx.globalCompositeOperation = 'source-over';
                    
                    if (this.tool === 'line') {
                        frameCtx.beginPath();
                        frameCtx.moveTo(x1, y1);
                        frameCtx.lineTo(x2, y2);
                        frameCtx.stroke();
                    } else if (this.tool === 'rect') {
                        frameCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    } else if (this.tool === 'circle') {
                        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        frameCtx.beginPath();
                        frameCtx.arc(x1, y1, radius, 0, Math.PI * 2);
                        frameCtx.stroke();
                    } else if (this.tool === 'triangle') {
                        drawTriangle(frameCtx);
                    }
                }
            }
            
            clearCurrentFrame() {
                this.saveState();
                const layer = this.getCurrentLayer();
                layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                this.render();
            }
            
            toggleOnionSkin() {
                this.onionSkinEnabled = !this.onionSkinEnabled;
                const btn = document.getElementById('onionSkinToggle');
                const checkbox = document.getElementById('onionEnabled');
                btn.style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                checkbox.checked = this.onionSkinEnabled;
                this.render();
            }
            
            // Render a tinted version of a frame onto the onion canvas
            drawOnionFrame(frame, tintColor, opacity) {
                // Create a temp canvas to composite the tint
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw the frame artwork
                tempCtx.drawImage(frame, 0, 0);
                
                // Apply a semi-transparent tint over only the artwork pixels
                // source-atop draws only where existing pixels are opaque
                tempCtx.globalCompositeOperation = 'source-atop';
                tempCtx.globalAlpha = 0.5;
                tempCtx.fillStyle = tintColor;
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.globalAlpha = 1;
                tempCtx.globalCompositeOperation = 'source-over';
                
                // Draw the tinted result onto the onion canvas
                this.onionCtx.globalAlpha = opacity;
                this.onionCtx.drawImage(tempCanvas, 0, 0);
                this.onionCtx.globalAlpha = 1;
            }
            
            addLayer() {
                this.commitSelection();
                this.saveState();
                
                const newLayer = {
                    id: this.nextLayerId++,
                    name: `Layer ${this.layers.length + 1}`,
                    visible: true,
                    opacity: 1.0,
                    frames: []
                };
                this.layers.push(newLayer);
                this.currentLayerId = newLayer.id;
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            duplicateLayer() {
                this.commitSelection();
                this.saveState();
                
                const currentLayer = this.getCurrentLayer();
                const newLayer = {
                    id: this.nextLayerId++,
                    name: currentLayer.name + ' copy',
                    visible: currentLayer.visible,
                    opacity: currentLayer.opacity,
                    frames: currentLayer.frames.map(frame => {
                        if (!frame) return null;
                        const copy = document.createElement('canvas');
                        copy.width = frame.width;
                        copy.height = frame.height;
                        copy.getContext('2d').drawImage(frame, 0, 0);
                        return copy;
                    })
                };
                
                // Insert after current layer
                const idx = this.layers.findIndex(l => l.id === this.currentLayerId);
                this.layers.splice(idx + 1, 0, newLayer);
                this.currentLayerId = newLayer.id;
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            deleteLayer() {
                // Don't delete if it's the only layer
                if (this.layers.length <= 1) {
                    alert('Cannot delete the only layer. Create another layer first.');
                    return;
                }
                
                this.commitSelection();
                this.saveState();
                
                // Find index of current layer
                const layerIndex = this.layers.findIndex(l => l.id === this.currentLayerId);
                
                // Remove the layer
                this.layers.splice(layerIndex, 1);
                
                // Select a different layer
                if (layerIndex >= this.layers.length) {
                    // If we deleted the last layer, select the new last layer
                    this.currentLayerId = this.layers[this.layers.length - 1].id;
                } else {
                    // Select the layer that took this position
                    this.currentLayerId = this.layers[layerIndex].id;
                }
                
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            previousFrame() {
                this.commitSelection();
                if (this.currentFrameIndex > 0) {
                    this.currentFrameIndex--;
                    this.initializeFrame();
                    this.render();
                }
            }
            
            goToNextFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                if (this.currentFrameIndex < layer.frames.length - 1) {
                    this.currentFrameIndex++;
                    this.initializeFrame();
                    this.render();
                }
            }
            
            nextFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Insert new blank frame after the current frame
                const newFrameIndex = this.currentFrameIndex + 1;
                
                // Create a new blank frame
                const newFrame = this.createEmptyFrame();
                
                // Insert the new frame at the position after current frame
                layer.frames.splice(newFrameIndex, 0, newFrame);
                
                // Move to the new frame
                this.currentFrameIndex = newFrameIndex;
                
                this.render();
            }
            
            insertFrameAfterCurrent() {
                // Same as nextFrame - inserts blank frame after current
                this.nextFrame();
            }
            
            deleteCurrentFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Don't delete if it's the only frame
                if (layer.frames.length <= 1) {
                    alert('Cannot delete the only frame. Create another frame first.');
                    return;
                }
                
                // Remove the current frame
                layer.frames.splice(this.currentFrameIndex, 1);
                
                // Adjust current frame index if needed
                if (this.currentFrameIndex >= layer.frames.length) {
                    this.currentFrameIndex = layer.frames.length - 1;
                }
                
                this.render();
            }
            
            // Lasso Selection Methods
            drawLassoPath() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                if (this.lassoPath.length < 2) return;
                
                this.selectionCtx.strokeStyle = '#0066cc';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.setLineDash([5, 5]);
                this.selectionCtx.beginPath();
                this.selectionCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                
                for (let i = 1; i < this.lassoPath.length; i++) {
                    this.selectionCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                
                this.selectionCtx.closePath();
                this.selectionCtx.stroke();
                this.selectionCtx.setLineDash([]);
            }
            
            completeLassoSelection() {
                if (this.lassoPath.length < 3) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Calculate lasso path bounds (used as initial working area)
                let lassoMinX = Infinity, lassoMinY = Infinity, lassoMaxX = -Infinity, lassoMaxY = -Infinity;
                for (let point of this.lassoPath) {
                    lassoMinX = Math.min(lassoMinX, point.x);
                    lassoMinY = Math.min(lassoMinY, point.y);
                    lassoMaxX = Math.max(lassoMaxX, point.x);
                    lassoMaxY = Math.max(lassoMaxY, point.y);
                }
                
                // Clamp to canvas bounds
                lassoMinX = Math.max(0, Math.floor(lassoMinX));
                lassoMinY = Math.max(0, Math.floor(lassoMinY));
                lassoMaxX = Math.min(this.canvas.width, Math.ceil(lassoMaxX));
                lassoMaxY = Math.min(this.canvas.height, Math.ceil(lassoMaxY));
                
                const lassoWidth = lassoMaxX - lassoMinX;
                const lassoHeight = lassoMaxY - lassoMinY;
                
                if (lassoWidth <= 0 || lassoHeight <= 0) {
                    this.lassoPath = [];
                    return;
                }
                
                // Get image data from current frame
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                // Create a mask for the lasso selection (full canvas size)
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = this.canvas.width;
                maskCanvas.height = this.canvas.height;
                const maskCtx = maskCanvas.getContext('2d');
                
                // Draw lasso path as mask
                maskCtx.fillStyle = 'white';
                maskCtx.beginPath();
                maskCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                for (let i = 1; i < this.lassoPath.length; i++) {
                    maskCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                maskCtx.closePath();
                maskCtx.fill();
                
                // Create masked selection at lasso bounds size
                const maskedCanvas = document.createElement('canvas');
                maskedCanvas.width = lassoWidth;
                maskedCanvas.height = lassoHeight;
                const maskedCtx = maskedCanvas.getContext('2d');
                
                // Copy frame content within lasso bounds
                maskedCtx.drawImage(frame, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                
                // Apply lasso mask
                maskedCtx.globalCompositeOperation = 'destination-in';
                maskedCtx.drawImage(maskCanvas, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                maskedCtx.globalCompositeOperation = 'source-over';
                
                // Scan pixel data to find tight bounding box of actual content
                const pixelData = maskedCtx.getImageData(0, 0, lassoWidth, lassoHeight);
                const pixels = pixelData.data;
                
                let tightMinX = lassoWidth, tightMinY = lassoHeight, tightMaxX = -1, tightMaxY = -1;
                
                for (let py = 0; py < lassoHeight; py++) {
                    for (let px = 0; px < lassoWidth; px++) {
                        const alpha = pixels[(py * lassoWidth + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < tightMinX) tightMinX = px;
                            if (px > tightMaxX) tightMaxX = px;
                            if (py < tightMinY) tightMinY = py;
                            if (py > tightMaxY) tightMaxY = py;
                        }
                    }
                }
                
                // If no pixels found, nothing to select
                if (tightMaxX < 0 || tightMaxY < 0) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Calculate tight bounds in canvas coordinates
                const tightWidth = tightMaxX - tightMinX + 1;
                const tightHeight = tightMaxY - tightMinY + 1;
                const finalX = lassoMinX + tightMinX;
                const finalY = lassoMinY + tightMinY;
                
                // Create final trimmed selection canvas
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = tightWidth;
                selectedCanvas.height = tightHeight;
                const selectedCtx = selectedCanvas.getContext('2d');
                
                // Copy only the tight region from the masked canvas
                selectedCtx.drawImage(maskedCanvas, tightMinX, tightMinY, tightWidth, tightHeight, 0, 0, tightWidth, tightHeight);
                
                // Store selection with tight bounds
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight },
                    originalBounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight }
                };
                
                // Erase selected area from original frame (using lasso path shape)
                frameCtx.save();
                frameCtx.globalCompositeOperation = 'destination-out';
                frameCtx.beginPath();
                frameCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                for (let i = 1; i < this.lassoPath.length; i++) {
                    frameCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                frameCtx.closePath();
                frameCtx.fill();
                frameCtx.restore();
                
                // Clear lasso path
                this.lassoPath = [];
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Transform Methods
            isPointInSelection(x, y) {
                if (!this.selection) return false;
                const b = this.selection.bounds;
                return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
            }
            
            showTransformHandles() {
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                
                // Initialize anchor point at center if not set
                if (!this.selection.anchorX || !this.selection.anchorY) {
                    this.selection.anchorX = b.x + b.width / 2;
                    this.selection.anchorY = b.y + b.height / 2;
                }
                
                // Initialize rotation if not set
                if (this.selection.rotation === undefined) {
                    this.selection.rotation = 0;
                }
                
                const rotation = this.selection.rotation;
                const anchorX = this.selection.anchorX;
                const anchorY = this.selection.anchorY;
                
                // Helper function to rotate a point around anchor
                const rotatePoint = (px, py) => {
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = px - anchorX;
                    const dy = py - anchorY;
                    return {
                        x: anchorX + dx * cos - dy * sin,
                        y: anchorY + dx * sin + dy * cos
                    };
                };
                
                // Calculate handle positions in unrotated space, then rotate them
                const unrotatedHandles = [
                    { x: b.x, y: b.y, type: 'nw' },
                    { x: b.x + b.width, y: b.y, type: 'ne' },
                    { x: b.x + b.width, y: b.y + b.height, type: 'se' },
                    { x: b.x, y: b.y + b.height, type: 'sw' },
                    { x: b.x + b.width / 2, y: b.y, type: 'n' },
                    { x: b.x + b.width, y: b.y + b.height / 2, type: 'e' },
                    { x: b.x + b.width / 2, y: b.y + b.height, type: 's' },
                    { x: b.x, y: b.y + b.height / 2, type: 'w' }
                ];
                
                // Rotate all handle positions
                this.transformHandles = unrotatedHandles.map(h => {
                    const rotated = rotatePoint(h.x, h.y);
                    return { x: rotated.x, y: rotated.y, type: h.type };
                });
                
                // Add anchor point (not rotated)
                this.transformHandles.push({ x: anchorX, y: anchorY, type: 'anchor' });
                
                this.drawTransformHandles();
            }
            
            hideTransformHandles() {
                this.transformHandles = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
            }
            
            drawTransformHandles() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                
                // Save context and apply rotation for the bounding box
                this.selectionCtx.save();
                this.selectionCtx.translate(anchorX, anchorY);
                this.selectionCtx.rotate(rotation);
                this.selectionCtx.translate(-anchorX, -anchorY);
                
                // Draw selection box (rotated)
                this.selectionCtx.strokeStyle = '#0066cc';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.setLineDash([5, 5]);
                this.selectionCtx.strokeRect(b.x, b.y, b.width, b.height);
                this.selectionCtx.setLineDash([]);
                
                // Restore context before drawing handles
                this.selectionCtx.restore();
                
                // Draw resize/rotate handles at their already-rotated positions
                // (handles are already at correct positions from showTransformHandles)
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    
                    this.selectionCtx.fillStyle = 'white';
                    this.selectionCtx.strokeStyle = '#0066cc';
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                }
                
                // Draw anchor point crosshair (NOT rotated - stays fixed)
                const anchorHandle = this.transformHandles.find(h => h.type === 'anchor');
                if (anchorHandle) {
                    this.selectionCtx.strokeStyle = '#ff6600';
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.beginPath();
                    this.selectionCtx.moveTo(anchorHandle.x - 8, anchorHandle.y);
                    this.selectionCtx.lineTo(anchorHandle.x + 8, anchorHandle.y);
                    this.selectionCtx.moveTo(anchorHandle.x, anchorHandle.y - 8);
                    this.selectionCtx.lineTo(anchorHandle.x, anchorHandle.y + 8);
                    this.selectionCtx.stroke();
                    
                    // Draw circle around anchor
                    this.selectionCtx.strokeStyle = '#ff6600';
                    this.selectionCtx.fillStyle = 'white';
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(anchorHandle.x, anchorHandle.y, 6, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                }
            }
            
            performTransform(x, y) {
                if (!this.selection || !this.activeHandle || !this.transformStart) return;
                
                const dx = x - this.transformStart.x;
                const dy = y - this.transformStart.y;
                
                if (this.activeHandle.type === 'move') {
                    // Move selection and anchor point together
                    this.selection.bounds.x += dx;
                    this.selection.bounds.y += dy;
                    this.selection.anchorX += dx;
                    this.selection.anchorY += dy;
                    this.transformStart = { x, y };
                } else if (this.activeHandle.type === 'anchor') {
                    // Move anchor point independently
                    this.selection.anchorX = x;
                    this.selection.anchorY = y;
                } else if (this.activeHandle.type === 'rotate' || this.isRotating) {
                    // Calculate rotation angle from anchor point
                    const anchorX = this.selection.anchorX;
                    const anchorY = this.selection.anchorY;
                    
                    // Calculate current angle from anchor to mouse position
                    const currentAngle = Math.atan2(y - anchorY, x - anchorX);
                    
                    // Calculate rotation delta from start
                    const angleDelta = currentAngle - this.startAngle;
                    
                    // Apply rotation
                    this.selection.rotation = this.initialRotation + angleDelta;
                } else {
                    // Resize selection
                    const b = this.selection.bounds;
                    const type = this.activeHandle.type;
                    
                    if (type.includes('n')) {
                        const newY = b.y + dy;
                        const newHeight = b.height - dy;
                        if (newHeight > 10) {
                            b.y = newY;
                            b.height = newHeight;
                        }
                    }
                    if (type.includes('s')) {
                        b.height += dy;
                        if (b.height < 10) b.height = 10;
                    }
                    if (type.includes('w')) {
                        const newX = b.x + dx;
                        const newWidth = b.width - dx;
                        if (newWidth > 10) {
                            b.x = newX;
                            b.width = newWidth;
                        }
                    }
                    if (type.includes('e')) {
                        b.width += dx;
                        if (b.width < 10) b.width = 10;
                    }
                    
                    this.transformStart = { x, y };
                }
                
                this.showTransformHandles();
                this.render();
            }
            
            applySelection() {
                if (!this.selection) return;
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                
                // Save context state
                frameCtx.save();
                
                // Apply rotation around anchor point
                frameCtx.translate(anchorX, anchorY);
                frameCtx.rotate(rotation);
                frameCtx.translate(-anchorX, -anchorY);
                
                // Draw the transformed selection onto the frame
                frameCtx.drawImage(
                    this.selection.imageData,
                    b.x, b.y, b.width, b.height
                );
                
                // Restore context state
                frameCtx.restore();
            }
            
            clearSelection() {
                this.selection = null;
                this.transformHandles = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
            }
            
            // Apply any active selection back to its frame and dismiss it
            commitSelection() {
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
            }
            
            // Clipboard Methods - Selection
            copySelection() {
                if (!this.selection) return;
                
                // Deep copy the selection image data to a new canvas
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = this.selection.imageData.width;
                copyCanvas.height = this.selection.imageData.height;
                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(this.selection.imageData, 0, 0);
                
                this.copiedSelection = {
                    imageData: copyCanvas,
                    width: this.selection.bounds.width,
                    height: this.selection.bounds.height,
                    x: this.selection.bounds.x,
                    y: this.selection.bounds.y
                };
                
                // Apply selection back to the frame and dismiss bounding box
                this.applySelection();
                this.clearSelection();
                this.selectTool('brush');
                this.render();
            }
            
            pasteSelection() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste centered on canvas
                const centerX = Math.round((this.canvas.width - this.copiedSelection.width) / 2);
                const centerY = Math.round((this.canvas.height - this.copiedSelection.height) / 2);
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool so the user can position it
                this.selectTool('transform');
                this.render();
            }
            
            pasteSelectionInPlace() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste at original position
                const origX = this.copiedSelection.x;
                const origY = this.copiedSelection.y;
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Clipboard Methods - Frames
            copyFrame(frameIndex) {
                const layer = this.getCurrentLayer();
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                // Deep copy the frame canvas
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = sourceFrame.width;
                copyCanvas.height = sourceFrame.height;
                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(sourceFrame, 0, 0);
                
                this.copiedFrame = copyCanvas;
            }
            
            pasteFrame(afterIndex) {
                if (!this.copiedFrame) return;
                
                this.commitSelection();
                this.saveState();
                
                const layer = this.getCurrentLayer();
                const idx = (afterIndex !== undefined) ? afterIndex : this.currentFrameIndex;
                
                // Create a new canvas with the copied content
                const newFrame = document.createElement('canvas');
                newFrame.width = this.copiedFrame.width;
                newFrame.height = this.copiedFrame.height;
                const newCtx = newFrame.getContext('2d');
                newCtx.drawImage(this.copiedFrame, 0, 0);
                
                // Insert after the target frame
                layer.frames.splice(idx + 1, 0, newFrame);
                
                // Navigate to the pasted frame
                this.currentFrameIndex = idx + 1;
                this.render();
            }
            
            duplicateFrame(frameIndex) {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                this.saveState();
                
                // Deep copy the frame
                const newFrame = document.createElement('canvas');
                newFrame.width = sourceFrame.width;
                newFrame.height = sourceFrame.height;
                const newCtx = newFrame.getContext('2d');
                newCtx.drawImage(sourceFrame, 0, 0);
                
                // Insert right after the source frame
                layer.frames.splice(idx + 1, 0, newFrame);
                
                // Navigate to the new duplicate
                this.currentFrameIndex = idx + 1;
                this.render();
            }
            
            // Flood Fill (Paint Bucket) Algorithm
            floodFill(startX, startY) {
                this.saveState();
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const ctx = frame.getContext('2d');
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                // Get target color (color to replace)
                const startPos = (startY * this.canvas.width + startX) * 4;
                const targetR = data[startPos];
                const targetG = data[startPos + 1];
                const targetB = data[startPos + 2];
                const targetA = data[startPos + 3];
                
                // Get fill color (selected color)
                const fillColor = this.hexToRgb(this.color);
                
                // Don't fill if target color is same as fill color
                if (targetR === fillColor.r && targetG === fillColor.g && 
                    targetB === fillColor.b && targetA === 255) {
                    return;
                }
                
                // Tolerance for anti-aliased edges (helps with smooth lines)
                const tolerance = 50;
                
                // Check if colors match within tolerance
                const colorMatch = (pos) => {
                    const r = data[pos];
                    const g = data[pos + 1];
                    const b = data[pos + 2];
                    const a = data[pos + 3];
                    
                    // If pixel is mostly transparent, it matches
                    if (a < 30) return true;
                    
                    // Calculate color difference
                    const dr = Math.abs(r - targetR);
                    const dg = Math.abs(g - targetG);
                    const db = Math.abs(b - targetB);
                    const da = Math.abs(a - targetA);
                    
                    return dr <= tolerance && dg <= tolerance && db <= tolerance && da <= tolerance;
                };
                
                // First pass: Standard flood fill
                const stack = [[startX, startY]];
                const filled = new Set();
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    
                    // Check bounds
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    
                    const key = `${x},${y}`;
                    if (filled.has(key)) continue;
                    
                    const pos = (y * width + x) * 4;
                    
                    // Check if pixel matches target color
                    if (colorMatch(pos)) {
                        filled.add(key);
                        
                        // Fill pixel
                        data[pos] = fillColor.r;
                        data[pos + 1] = fillColor.g;
                        data[pos + 2] = fillColor.b;
                        data[pos + 3] = 255;
                        
                        // Add adjacent pixels to stack
                        stack.push([x + 1, y]);
                        stack.push([x - 1, y]);
                        stack.push([x, y + 1]);
                        stack.push([x, y - 1]);
                    }
                }
                
                // Second pass: Fill anti-aliased edge pixels
                // This eliminates white fringing around linework
                const edgePixels = new Set();
                for (const key of filled) {
                    const [fx, fy] = key.split(',').map(Number);
                    
                    // Check 8 surrounding pixels for edge detection
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = fx + dx;
                            const ny = fy + dy;
                            const nkey = `${nx},${ny}`;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height && !filled.has(nkey)) {
                                const pos = (ny * width + nx) * 4;
                                const a = data[pos + 3];
                                
                                // If it's a semi-transparent pixel (anti-aliasing), blend it
                                if (a > 0 && a < 200) {
                                    edgePixels.add(nkey);
                                }
                            }
                        }
                    }
                }
                
                // Fill edge pixels with blended color
                for (const key of edgePixels) {
                    const [ex, ey] = key.split(',').map(Number);
                    const pos = (ey * width + ex) * 4;
                    
                    const oldR = data[pos];
                    const oldG = data[pos + 1];
                    const oldB = data[pos + 2];
                    const oldA = data[pos + 3];
                    
                    // Blend the fill color with existing pixel
                    const blendFactor = oldA / 255;
                    data[pos] = Math.round(fillColor.r * (1 - blendFactor) + oldR * blendFactor);
                    data[pos + 1] = Math.round(fillColor.g * (1 - blendFactor) + oldG * blendFactor);
                    data[pos + 2] = Math.round(fillColor.b * (1 - blendFactor) + oldB * blendFactor);
                    data[pos + 3] = 255;
                }
                
                // Put modified image data back
                ctx.putImageData(imageData, 0, 0);
                this.render();
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 0, g: 0, b: 0};
            }
            
            play() {
                if (this.isPlaying) return;
                this.commitSelection();
                this.isPlaying = true;
                
                const layer = this.getCurrentLayer();
                const maxFrames = layer.frames.length;
                let frameIndex = 0;
                
                this.playbackInterval = setInterval(() => {
                    this.currentFrameIndex = frameIndex;
                    this.render();
                    frameIndex = (frameIndex + 1) % maxFrames;
                }, 1000 / this.fps);
            }
            
            stop() {
                this.isPlaying = false;
                if (this.playbackInterval) {
                    clearInterval(this.playbackInterval);
                    this.playbackInterval = null;
                }
            }
            
            render() {
                // Position onion canvas
                this.positionOnionCanvas();
                
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Clear onion skin canvas
                this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                
                // Draw onion skin (previous and next frames)
                if (this.onionSkinEnabled) {
                    const layer = this.getCurrentLayer();
                    
                    // Draw previous frames (tinted with prevColor)
                    for (let offset = 1; offset <= this.onionFramesBefore; offset++) {
                        const frameIdx = this.currentFrameIndex - offset;
                        if (frameIdx >= 0) {
                            const prevFrame = layer.frames[frameIdx];
                            if (prevFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesBefore, 1));
                                this.drawOnionFrame(prevFrame, this.onionPrevColor, fadeOpacity);
                            }
                        }
                    }
                    
                    // Draw next frames (tinted with nextColor)
                    for (let offset = 1; offset <= this.onionFramesAfter; offset++) {
                        const frameIdx = this.currentFrameIndex + offset;
                        if (frameIdx < layer.frames.length) {
                            const nextFrame = layer.frames[frameIdx];
                            if (nextFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesAfter, 1));
                                this.drawOnionFrame(nextFrame, this.onionNextColor, fadeOpacity);
                            }
                        }
                    }
                }
                
                // Draw all visible layers for current frame ON THE MAIN CANVAS
                for (const layer of this.layers) {
                    if (layer.visible && layer.frames[this.currentFrameIndex]) {
                        this.ctx.globalAlpha = layer.opacity || 1.0;
                        this.ctx.drawImage(layer.frames[this.currentFrameIndex], 0, 0);
                        this.ctx.globalAlpha = 1.0;
                    }
                }
                
                // Draw selection if it exists (with rotation)
                if (this.selection) {
                    const b = this.selection.bounds;
                    const rotation = this.selection.rotation || 0;
                    const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                    const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                    
                    // Save context state
                    this.ctx.save();
                    
                    // Apply rotation around anchor point
                    this.ctx.translate(anchorX, anchorY);
                    this.ctx.rotate(rotation);
                    this.ctx.translate(-anchorX, -anchorY);
                    
                    // Draw the selection
                    this.ctx.drawImage(
                        this.selection.imageData,
                        b.x, b.y, b.width, b.height
                    );
                    
                    // Restore context state
                    this.ctx.restore();
                }
                
                this.renderTimeline();
                this.renderLayers();
            }
            
            renderLayers() {
                const layersList = document.getElementById('layersList');
                layersList.innerHTML = '';
                
                [...this.layers].reverse().forEach((layer, reversedIndex) => {
                    const actualIndex = this.layers.length - 1 - reversedIndex;
                    
                    const div = document.createElement('div');
                    div.className = 'layer-item' + (layer.id === this.currentLayerId ? ' active' : '');
                    div.draggable = true;
                    div.dataset.layerId = layer.id;
                    
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'layer-header';
                    
                    const visibilitySpan = document.createElement('span');
                    visibilitySpan.className = 'layer-visibility';
                    visibilitySpan.textContent = layer.visible ? 'üëÅÔ∏è' : 'üö´';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'layer-name';
                    nameSpan.textContent = layer.name;
                    
                    headerDiv.appendChild(visibilitySpan);
                    headerDiv.appendChild(nameSpan);
                    
                    // Opacity control
                    const opacityDiv = document.createElement('div');
                    opacityDiv.className = 'layer-opacity-control';
                    
                    const opacityLabel = document.createElement('span');
                    opacityLabel.textContent = 'Opacity:';
                    
                    const opacitySlider = document.createElement('input');
                    opacitySlider.type = 'range';
                    opacitySlider.min = '0';
                    opacitySlider.max = '100';
                    opacitySlider.value = Math.round((layer.opacity || 1.0) * 100);
                    
                    const opacityValue = document.createElement('span');
                    opacityValue.className = 'layer-opacity-value';
                    opacityValue.textContent = Math.round((layer.opacity || 1.0) * 100) + '%';
                    
                    opacitySlider.addEventListener('input', (e) => {
                        e.stopPropagation();
                        const newOpacity = parseInt(e.target.value) / 100;
                        layer.opacity = newOpacity;
                        opacityValue.textContent = Math.round(newOpacity * 100) + '%';
                        this.render();
                    });
                    
                    opacityDiv.appendChild(opacityLabel);
                    opacityDiv.appendChild(opacitySlider);
                    opacityDiv.appendChild(opacityValue);
                    
                    div.appendChild(headerDiv);
                    div.appendChild(opacityDiv);
                    
                    // Click handlers
                    headerDiv.addEventListener('click', (e) => {
                        if (e.target.classList.contains('layer-visibility')) {
                            layer.visible = !layer.visible;
                            this.render();
                        } else {
                            this.commitSelection();
                            this.currentLayerId = layer.id;
                            this.initializeFrame();
                            this.render();
                        }
                    });
                    
                    // Drag and drop handlers
                    div.addEventListener('dragstart', (e) => {
                        this.draggedLayerId = layer.id;
                        div.classList.add('dragging');
                    });
                    
                    div.addEventListener('dragend', (e) => {
                        div.classList.remove('dragging');
                        this.draggedLayerId = null;
                        this.dropTargetLayerId = null;
                        // Remove all drop indicators
                        document.querySelectorAll('.layer-item').forEach(item => {
                            item.classList.remove('drop-before', 'drop-after');
                        });
                    });
                    
                    div.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (this.draggedLayerId === null || this.draggedLayerId === layer.id) return;
                        
                        const rect = div.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;
                        
                        // Remove all drop indicators first
                        document.querySelectorAll('.layer-item').forEach(item => {
                            item.classList.remove('drop-before', 'drop-after');
                        });
                        
                        if (e.clientY < midpoint) {
                            div.classList.add('drop-before');
                            this.dropTargetLayerId = layer.id;
                            this.dropPosition = 'before';
                        } else {
                            div.classList.add('drop-after');
                            this.dropTargetLayerId = layer.id;
                            this.dropPosition = 'after';
                        }
                    });
                    
                    div.addEventListener('drop', (e) => {
                        e.preventDefault();
                        if (this.draggedLayerId === null || this.dropTargetLayerId === null) return;
                        
                        // Find indices
                        const draggedIndex = this.layers.findIndex(l => l.id === this.draggedLayerId);
                        const targetIndex = this.layers.findIndex(l => l.id === this.dropTargetLayerId);
                        
                        if (draggedIndex === -1 || targetIndex === -1) return;
                        
                        // Remove dragged layer
                        const [draggedLayer] = this.layers.splice(draggedIndex, 1);
                        
                        // Calculate new index (account for removed item)
                        let newIndex = targetIndex;
                        if (draggedIndex < targetIndex) {
                            newIndex--;
                        }
                        
                        if (this.dropPosition === 'before') {
                            newIndex++;
                        }
                        
                        // Insert at new position
                        this.layers.splice(newIndex, 0, draggedLayer);
                        
                        // Re-render
                        this.renderLayers();
                        this.render();
                    });
                    
                    layersList.appendChild(div);
                });
            }
            
            renderTimeline() {
                const container = document.getElementById('framesContainer');
                container.innerHTML = '';
                
                const layer = this.getCurrentLayer();
                const maxFrames = Math.max(layer.frames.length, this.currentFrameIndex + 1);
                
                for (let i = 0; i < maxFrames; i++) {
                    const frameDiv = document.createElement('div');
                    frameDiv.className = 'frame' + (i === this.currentFrameIndex ? ' active' : '');
                    frameDiv.draggable = true;
                    frameDiv.dataset.frameIndex = i;
                    
                    if (layer.frames[i]) {
                        const thumbnail = document.createElement('canvas');
                        thumbnail.width = 80;
                        thumbnail.height = 60;
                        const thumbCtx = thumbnail.getContext('2d');
                        thumbCtx.drawImage(layer.frames[i], 0, 0, 80, 60);
                        frameDiv.appendChild(thumbnail);
                    }
                    
                    const frameNumber = document.createElement('div');
                    frameNumber.className = 'frame-number';
                    frameNumber.textContent = i + 1;
                    frameDiv.appendChild(frameNumber);
                    
                    // Click to select frame
                    frameDiv.addEventListener('click', (e) => {
                        // Don't select if we just finished dragging
                        if (this.justDropped) {
                            this.justDropped = false;
                            return;
                        }
                        this.commitSelection();
                        this.currentFrameIndex = i;
                        this.initializeFrame();
                        this.render();
                    });
                    
                    // Right-click context menu
                    frameDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.contextMenuFrameIndex = i;
                        
                        const ctxMenu = document.getElementById('frameContextMenu');
                        const pasteItem = document.getElementById('ctxPasteFrame');
                        
                        // Enable/disable paste based on clipboard
                        if (this.copiedFrame) {
                            pasteItem.classList.remove('disabled');
                        } else {
                            pasteItem.classList.add('disabled');
                        }
                        
                        // Position the menu
                        ctxMenu.style.left = e.clientX + 'px';
                        ctxMenu.style.top = e.clientY + 'px';
                        ctxMenu.classList.add('show');
                        
                        // Keep menu within viewport
                        const menuRect = ctxMenu.getBoundingClientRect();
                        if (menuRect.right > window.innerWidth) {
                            ctxMenu.style.left = (e.clientX - menuRect.width) + 'px';
                        }
                        if (menuRect.bottom > window.innerHeight) {
                            ctxMenu.style.top = (e.clientY - menuRect.height) + 'px';
                        }
                    });
                    
                    // Drag start
                    frameDiv.addEventListener('dragstart', (e) => {
                        this.draggedFrameIndex = i;
                        frameDiv.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', frameDiv.innerHTML);
                    });
                    
                    // Drag end
                    frameDiv.addEventListener('dragend', (e) => {
                        frameDiv.classList.remove('dragging');
                        document.querySelectorAll('.frame').forEach(f => f.classList.remove('drag-over'));
                    });
                    
                    // Drag over
                    frameDiv.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        frameDiv.classList.add('drag-over');
                        this.dropTargetIndex = i;
                    });
                    
                    // Drag leave
                    frameDiv.addEventListener('dragleave', (e) => {
                        frameDiv.classList.remove('drag-over');
                    });
                    
                    // Drop
                    frameDiv.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        frameDiv.classList.remove('drag-over');
                        
                        if (this.draggedFrameIndex !== null && this.draggedFrameIndex !== i) {
                            this.reorderFrames(this.draggedFrameIndex, i);
                            this.justDropped = true;
                        }
                        
                        this.draggedFrameIndex = null;
                        this.dropTargetIndex = null;
                    });
                    
                    container.appendChild(frameDiv);
                }
                
                // Add new frame button
                const addFrameDiv = document.createElement('div');
                addFrameDiv.className = 'add-frame';
                addFrameDiv.textContent = '+';
                addFrameDiv.title = 'Add new frame after current frame';
                addFrameDiv.addEventListener('click', () => this.nextFrame());
                container.appendChild(addFrameDiv);
            }
            
            reorderFrames(fromIndex, toIndex) {
                const layer = this.getCurrentLayer();
                
                // Remove the frame from its original position
                const [movedFrame] = layer.frames.splice(fromIndex, 1);
                
                // Insert it at the new position
                layer.frames.splice(toIndex, 0, movedFrame);
                
                // Update current frame index if needed
                if (this.currentFrameIndex === fromIndex) {
                    this.currentFrameIndex = toIndex;
                } else if (fromIndex < this.currentFrameIndex && toIndex >= this.currentFrameIndex) {
                    this.currentFrameIndex--;
                } else if (fromIndex > this.currentFrameIndex && toIndex <= this.currentFrameIndex) {
                    this.currentFrameIndex++;
                }
                
                this.render();
            }
            
            async exportGif() {
                const layer = this.getCurrentLayer();
                if (layer.frames.length === 0) {
                    alert('No frames to export!');
                    return;
                }
                
                // Export as PNG frames ZIP
                this.exportFramesAsPNG();
            }
            
            async exportAsVideo(exportBtn, originalText) {
                exportBtn.textContent = 'Creating video...';
                exportBtn.disabled = true;
                
                try {
                    // Calculate total number of frames (max across all layers)
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Check if browser supports MediaRecorder
                    if (!window.MediaRecorder) {
                        throw new Error('Video recording not supported in this browser');
                    }
                    
                    // Create a temporary canvas for recording
                    const recordCanvas = document.createElement('canvas');
                    recordCanvas.width = this.canvas.width;
                    recordCanvas.height = this.canvas.height;
                    const recordCtx = recordCanvas.getContext('2d');
                    
                    // Get canvas stream
                    const stream = recordCanvas.captureStream(this.fps);
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 2500000
                    });
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `frameboy-animation-${Date.now()}.webm`;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
                        
                        exportBtn.textContent = '‚úì Video Downloaded!';
                        setTimeout(() => {
                            exportBtn.textContent = originalText;
                            exportBtn.disabled = false;
                        }, 2000);
                    };
                    
                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                        alert('Video recording failed. Downloading frames as PNG instead.');
                        this.exportFramesAsPNG();
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    
                    // Play through all frames
                    const frameDelay = 1000 / this.fps;
                    let currentFrame = 0;
                    
                    const drawNextFrame = () => {
                        if (currentFrame < maxFrames) {
                            // Clear and draw white background
                            recordCtx.fillStyle = 'white';
                            recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
                            
                            // Draw all visible layers for this frame
                            for (const layer of this.layers) {
                                if (layer.visible && layer.frames[currentFrame]) {
                                    recordCtx.globalAlpha = layer.opacity || 1.0;
                                    recordCtx.drawImage(layer.frames[currentFrame], 0, 0);
                                    recordCtx.globalAlpha = 1.0;
                                }
                            }
                            
                            // Update progress
                            const progress = Math.round((currentFrame / maxFrames) * 100);
                            exportBtn.textContent = `Recording... ${progress}%`;
                            
                            currentFrame++;
                            setTimeout(drawNextFrame, frameDelay);
                        } else {
                            // Loop once more to ensure smooth playback
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, frameDelay * 2);
                        }
                    };
                    
                    drawNextFrame();
                    
                } catch (error) {
                    console.error('Video export error:', error);
                    exportBtn.textContent = originalText;
                    exportBtn.disabled = false;
                    
                    const usePNG = confirm(`Video export failed: ${error.message}\n\nWould you like to download frames as PNG images instead?`);
                    if (usePNG) {
                        this.exportFramesAsPNG();
                    }
                }
            }
            
            async loadGifJS() {
                // No longer used, kept for compatibility
                return Promise.resolve();
            }
            
            async exportFramesAsPNG() {
                const exportBtn = document.getElementById('exportBtn');
                
                if (!exportBtn) {
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.textContent;
                
                exportBtn.textContent = 'Creating ZIP...';
                exportBtn.disabled = true;
                
                try {
                    // Load JSZip library
                    if (typeof JSZip === 'undefined') {
                        await this.loadJSZip();
                    }
                    
                    const zip = new JSZip();
                    
                    // Calculate max frames
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Create a temporary canvas for compositing
                    const compositeCanvas = document.createElement('canvas');
                    compositeCanvas.width = this.canvas.width;
                    compositeCanvas.height = this.canvas.height;
                    const compositeCtx = compositeCanvas.getContext('2d');
                    
                    // Create folders for each layer and composite
                    const compositeFolderName = 'composite-all-layers';
                    const compositeFolder = zip.folder(compositeFolderName);
                    
                    // Export each layer into its own folder
                    for (const layer of this.layers) {
                        if (layer.frames.length > 0) {
                            const layerFolderName = layer.name.replace(/[^a-z0-9]/gi, '_');
                            const layerFolder = zip.folder(layerFolderName);
                            
                            for (let i = 0; i < layer.frames.length; i++) {
                                const frame = layer.frames[i];
                                if (frame) {
                                    // Convert frame to blob
                                    const blob = await new Promise(resolve => {
                                        frame.toBlob(resolve, 'image/png');
                                    });
                                    
                                    // Add to layer folder
                                    const filename = `frame_${String(i + 1).padStart(3, '0')}.png`;
                                    layerFolder.file(filename, blob);
                                }
                            }
                        }
                    }
                    
                    // Export composite frames (all visible layers combined)
                    for (let i = 0; i < maxFrames; i++) {
                        // Clear canvas with white background
                        compositeCtx.fillStyle = 'white';
                        compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                        
                        // Draw all visible layers for this frame
                        for (const layer of this.layers) {
                            if (layer.visible && layer.frames[i]) {
                                compositeCtx.globalAlpha = layer.opacity || 1.0;
                                compositeCtx.drawImage(layer.frames[i], 0, 0);
                                compositeCtx.globalAlpha = 1.0;
                            }
                        }
                        
                        // Convert composite to blob
                        const blob = await new Promise(resolve => {
                            compositeCanvas.toBlob(resolve, 'image/png');
                        });
                        
                        // Add to composite folder
                        const filename = `frame_${String(i + 1).padStart(3, '0')}.png`;
                        compositeFolder.file(filename, blob);
                        
                        // Update progress
                        const totalProgress = Math.round((i / maxFrames) * 100);
                        exportBtn.textContent = `Creating composite... ${totalProgress}%`;
                    }
                    
                    // Generate zip file
                    exportBtn.textContent = 'Generating ZIP file...';
                    const zipBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: 6 }
                    }, (metadata) => {
                        const progress = Math.round(metadata.percent);
                        exportBtn.textContent = `Compressing... ${progress}%`;
                    });
                    
                    // Download the zip
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `animation-frames-${Date.now()}.zip`;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 100);
                    
                    exportBtn.textContent = '‚úì ZIP Downloaded!';
                    setTimeout(() => {
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                    }, 2000);
                    
                } catch (error) {
                    console.error('ZIP export error:', error);
                    exportBtn.textContent = originalText;
                    exportBtn.disabled = false;
                    alert(`Failed to create ZIP file: ${error.message}\n\nFrames will download individually instead.`);
                    
                    // Fallback to individual downloads
                    this.exportFramesIndividually();
                }
            }
            
            async exportAsGif() {
                // Get export button with very specific check
                const exportBtn = document.getElementById('exportBtn');
                
                if (!exportBtn || exportBtn.id !== 'exportBtn') {
                    console.error('Export button not found correctly');
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.textContent;
                console.log('Export button original text:', originalText);
                
                try {
                    exportBtn.textContent = 'Preparing GIF...';
                    exportBtn.disabled = true;
                    
                    // Calculate total frames
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Check if gifshot is loaded
                    if (typeof gifshot === 'undefined') {
                        throw new Error('GIF library not loaded. Please refresh the page.');
                    }
                    
                    // Create temporary canvas for rendering
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.canvas.width;
                    tempCanvas.height = this.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Render all frames as data URLs
                    exportBtn.textContent = 'Rendering frames...';
                    const frameImages = [];
                    
                    for (let i = 0; i < maxFrames; i++) {
                        // Clear canvas
                        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Render all visible layers for this frame
                        for (const layer of this.layers) {
                            if (!layer.visible) continue;
                            
                            const frame = layer.frames[i];
                            if (frame) {
                                tempCtx.globalAlpha = layer.opacity || 1.0;
                                tempCtx.drawImage(frame, 0, 0);
                                tempCtx.globalAlpha = 1.0;
                            }
                        }
                        
                        // Convert to data URL
                        frameImages.push(tempCanvas.toDataURL('image/png'));
                        
                        // Update progress - double check we have the right button
                        const currentBtn = document.getElementById('exportBtn');
                        if (currentBtn && currentBtn.id === 'exportBtn') {
                            const progress = Math.round((i / maxFrames) * 50);
                            currentBtn.textContent = `Rendering frames... ${progress}%`;
                        }
                    }
                    
                    // Create GIF from frames
                    const statusBtn = document.getElementById('exportBtn');
                    if (statusBtn && statusBtn.id === 'exportBtn') {
                        statusBtn.textContent = 'Creating GIF... 50%';
                    }
                    
                    gifshot.createGIF({
                        images: frameImages,
                        gifWidth: this.canvas.width,
                        gifHeight: this.canvas.height,
                        interval: 1 / this.fps,
                        numFrames: maxFrames,
                        frameDuration: 1,
                        sampleInterval: 10,
                        numWorkers: 2
                    }, (obj) => {
                        if (!obj.error) {
                            // Convert base64 to blob
                            const base64Data = obj.image.split(',')[1];
                            const byteCharacters = atob(base64Data);
                            const byteArrays = [];
                            
                            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                                const slice = byteCharacters.slice(offset, offset + 512);
                                const byteNumbers = new Array(slice.length);
                                for (let i = 0; i < slice.length; i++) {
                                    byteNumbers[i] = slice.charCodeAt(i);
                                }
                                byteArrays.push(new Uint8Array(byteNumbers));
                            }
                            
                            const blob = new Blob(byteArrays, { type: 'image/gif' });
                            
                            // Download
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `frameboy-animation-${Date.now()}.gif`;
                            document.body.appendChild(a);
                            a.click();
                            
                            setTimeout(() => {
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                            }, 100);
                            
                            // Restore button - get fresh reference and verify it
                            const finalBtn = document.getElementById('exportBtn');
                            if (finalBtn && finalBtn.id === 'exportBtn') {
                                console.log('Restoring export button to:', originalText);
                                finalBtn.textContent = '‚úì GIF Downloaded!';
                                finalBtn.disabled = false;
                                setTimeout(() => {
                                    const restoreBtn = document.getElementById('exportBtn');
                                    if (restoreBtn && restoreBtn.id === 'exportBtn') {
                                        restoreBtn.textContent = originalText;
                                    }
                                }, 2000);
                            }
                        } else {
                            throw new Error(obj.error);
                        }
                    });
                    
                } catch (error) {
                    console.error('GIF export error:', error);
                    const errorBtn = document.getElementById('exportBtn');
                    if (errorBtn && errorBtn.id === 'exportBtn') {
                        errorBtn.textContent = originalText;
                        errorBtn.disabled = false;
                    }
                    alert(`Failed to create GIF: ${error.message}\n\nTry PNG ZIP export instead.`);
                }
            }
            
            exportFramesIndividually() {
                const layer = this.getCurrentLayer();
                
                setTimeout(() => {
                    layer.frames.forEach((frame, index) => {
                        if (frame) {
                            setTimeout(() => {
                                frame.toBlob((blob) => {
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `frame_${String(index + 1).padStart(3, '0')}.png`;
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(url);
                                });
                            }, index * 200);
                        }
                    });
                }, 100);
                
                alert(`Downloading ${layer.frames.length} frames as individual PNG files!`);
            }
            
            async loadJSZip() {
                return new Promise((resolve, reject) => {
                    if (typeof JSZip !== 'undefined') {
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.async = true;
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('JSZip library took too long to load'));
                    }, 10000);
                    
                    script.onload = () => {
                        clearTimeout(timeout);
                        setTimeout(() => {
                            if (typeof JSZip !== 'undefined') {
                                resolve();
                            } else {
                                reject(new Error('JSZip library loaded but not available'));
                            }
                        }, 100);
                    };
                    
                    script.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load JSZip library'));
                    };
                    
                    document.head.appendChild(script);
                });
            }
            
            exportSpriteSheet() {
                const layer = this.getCurrentLayer();
                const frameCount = layer.frames.length;
                
                if (frameCount === 0) return;
                
                // Create a sprite sheet with all frames in a row
                const frameWidth = this.canvas.width;
                const frameHeight = this.canvas.height;
                const spriteSheet = document.createElement('canvas');
                spriteSheet.width = frameWidth * frameCount;
                spriteSheet.height = frameHeight;
                const ctx = spriteSheet.getContext('2d');
                
                // Draw white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, spriteSheet.width, spriteSheet.height);
                
                // Draw each frame
                layer.frames.forEach((frame, index) => {
                    if (frame) {
                        ctx.drawImage(frame, index * frameWidth, 0);
                    }
                });
                
                // Download the sprite sheet
                spriteSheet.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'animation_spritesheet.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    alert('Sprite sheet downloaded! You can use this with CSS animations or game engines.');
                });
            }
        }
        
        // Initialize the app
        const app = new AnimationStudio();
    </script>
</body>
</html>
